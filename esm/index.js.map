{
  "version": 3,
  "sources": ["../lib/index.ts", "../lib/is-have-indexed-db.ts", "../lib/index.ts"],
  "sourcesContent": [
    "import { debounce } from \"throttle-debounce\";\nimport { isHaveIndexedDb } from \"./is-have-indexed-db\";\n\ninterface IndexedRedisOptions<T> {\n\tdbName: string;\n\tdefaultValue: T;\n\toptimisticDelay?: number;\n\tignoreCache?: boolean;\n\tonlyUseLocalStorage?: boolean;\n\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\tsetFormat?: (value: any) => any | Promise<any>;\n\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\tgetFormat?: (value: any) => any | Promise<any>;\n}\n\nconst baseFormat = (v: unknown) => v;\n\nexport type IndexedRedis<T> = ReturnType<typeof IndexedRedis<T>>;\n\nexport function IndexedRedis<T>(options: IndexedRedisOptions<T>) {\n\tconst dbName = options.dbName;\n\tconst defaultValue = options.defaultValue;\n\tconst optimisticDelay = options.optimisticDelay || 500;\n\tconst isUseIndexedDb = options.onlyUseLocalStorage ? false : isHaveIndexedDb;\n\tconst setFormat = options.setFormat || baseFormat;\n\tconst getFormat = options.getFormat || baseFormat;\n\tconst ignoreCache = options.ignoreCache || false;\n\tconst oldKeys = localStorage.getItem(`[${dbName}-keys]`);\n\tlet hasKeys: Record<string, number> = {};\n\tif (oldKeys) {\n\t\ttry {\n\t\t\thasKeys = JSON.parse(oldKeys);\n\t\t} catch (error) {\n\t\t\t//\n\t\t}\n\t}\n\n\tconst valueCache: Record<string, { expire: number; value: unknown }> = {};\n\tconst setExJobs: Record<string, { expire: number; value: unknown }> = {};\n\tlet db: IDBDatabase | undefined;\n\tlet initd = localStorage.getItem(`indexed-redis-initd-${dbName}`) === \"true\";\n\n\tconst getDefaultValue = <K extends keyof T>(key: K): T[K] => {\n\t\tif (defaultValue[key] === void 0) {\n\t\t\treturn defaultValue[key];\n\t\t}\n\t\treturn JSON.parse(JSON.stringify(defaultValue[key]));\n\t};\n\n\tconst runSetExJobs = debounce(optimisticDelay, () => {\n\t\tconst keys = Object.keys(setExJobs);\n\t\tif (keys.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tkeys.forEach((key) => {\n\t\t\tconst job = setExJobs[key];\n\t\t\tif (job) {\n\t\t\t\tsetWithFormat(key, job);\n\t\t\t}\n\t\t\tdelete setExJobs[key];\n\t\t});\n\t});\n\n\tconst saveOtherLocal = () => {\n\t\tlocalStorage.setItem(`[${dbName}-keys]`, JSON.stringify(hasKeys));\n\t};\n\n\tconst initDb = async () => {\n\t\tif (db) {\n\t\t\treturn;\n\t\t}\n\t\tif (!initd) {\n\t\t\tlocalStorage.setItem(`indexed-redis-initd-${dbName}`, \"true\");\n\t\t\tinitd = true;\n\t\t}\n\t\tif (!isUseIndexedDb) {\n\t\t\treturn;\n\t\t}\n\t\treturn new Promise((res) => {\n\t\t\tif (!db) {\n\t\t\t\tconst reqDb = window.indexedDB.open(dbName);\n\t\t\t\treqDb.onerror = console.error;\n\t\t\t\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\t\t\t\treqDb.onsuccess = (event: any) => {\n\t\t\t\t\tif (!db) {\n\t\t\t\t\t\tdb = event.target.result;\n\t\t\t\t\t}\n\t\t\t\t\tres(void 0);\n\t\t\t\t};\n\t\t\t\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\t\t\t\treqDb.onupgradeneeded = (event: any) => {\n\t\t\t\t\tif (!db) {\n\t\t\t\t\t\tdb = event.target.result;\n\t\t\t\t\t}\n\t\t\t\t\tdb?.createObjectStore(dbName, {\n\t\t\t\t\t\tautoIncrement: false,\n\t\t\t\t\t\tkeyPath: \"key\",\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tres(void 0);\n\t\t\t}\n\t\t});\n\t};\n\tconst delDb = async <K extends keyof T>(key: K) => {\n\t\tawait initDb();\n\t\tsaveOtherLocal();\n\t\tif (!isUseIndexedDb) {\n\t\t\tlocalStorage.removeItem(`[${dbName}] ${key as string}`);\n\t\t}\n\t\treturn new Promise((res) => {\n\t\t\tif (db) {\n\t\t\t\tconst transaction = db.transaction([dbName], \"readwrite\");\n\t\t\t\tconst objectStore = transaction.objectStore(dbName);\n\t\t\t\tconst request = objectStore.delete(key as string);\n\t\t\t\trequest.onerror = (err) => {\n\t\t\t\t\tconsole.error(err);\n\t\t\t\t\tres(void 0);\n\t\t\t\t};\n\t\t\t\trequest.onsuccess = () => {\n\t\t\t\t\tres(void 0);\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tres(void 0);\n\t\t\t}\n\t\t});\n\t};\n\tconst setDb = async (key: string, value: unknown) => {\n\t\tawait initDb();\n\t\tsaveOtherLocal();\n\t\tif (!isUseIndexedDb) {\n\t\t\tlocalStorage.setItem(\n\t\t\t\t`[${dbName}] ${key as string}`,\n\t\t\t\tJSON.stringify({\n\t\t\t\t\tpis: value,\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\t\treturn new Promise((res) => {\n\t\t\tif (db) {\n\t\t\t\tconst transaction = db.transaction([dbName], \"readwrite\");\n\t\t\t\tconst objectStore = transaction.objectStore(dbName);\n\t\t\t\tconst data = {\n\t\t\t\t\tkey: key,\n\t\t\t\t\tvalue: value,\n\t\t\t\t};\n\t\t\t\tconst request = objectStore.put(data);\n\t\t\t\trequest.onerror = (err) => {\n\t\t\t\t\tconsole.error(err);\n\t\t\t\t\tres(void 0);\n\t\t\t\t};\n\t\t\t\trequest.onsuccess = () => {\n\t\t\t\t\tres(void 0);\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tres(void 0);\n\t\t\t}\n\t\t});\n\t};\n\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\tconst getDb = async (key: any): Promise<any> => {\n\t\tawait initDb();\n\t\tif (!isUseIndexedDb) {\n\t\t\tconst old = localStorage.getItem(`[${dbName}] ${key as string}`);\n\t\t\tif (old === void 0 || old === null) {\n\t\t\t\treturn void 0;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\treturn JSON.parse(old as string).pis;\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(\"[indexed-redis] get error:\", error);\n\t\t\t\treturn void 0;\n\t\t\t}\n\t\t}\n\t\treturn new Promise((res) => {\n\t\t\tif (db) {\n\t\t\t\tconst transaction = db.transaction([dbName], \"readonly\");\n\t\t\t\tconst objectStore = transaction.objectStore(dbName);\n\t\t\t\tconst request = objectStore.get(key as string);\n\t\t\t\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\t\t\t\trequest.onsuccess = (event: any) => {\n\t\t\t\t\tconst data = event.target.result;\n\t\t\t\t\tif (data?.value === void 0) {\n\t\t\t\t\t\tres(void 0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tres(data?.value);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tres(void 0);\n\t\t\t}\n\t\t});\n\t};\n\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\tconst getWithFormat = async (key: any): Promise<any> => {\n\t\tconst data = await getDb(key);\n\t\tif (data === void 0 || data === null) {\n\t\t\treturn data;\n\t\t}\n\t\treturn Promise.resolve(getFormat(data));\n\t};\n\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\tconst setWithFormat = async (key: any, value: any) => {\n\t\tconst nextValue = await Promise.resolve(setFormat(value));\n\t\treturn setDb(key, nextValue);\n\t};\n\n\tconst set = (key: keyof T, value: T[keyof T]) => {\n\t\treturn setExWithCache(key, 0, value);\n\t};\n\n\t// use cache\n\tconst setExWithCache = async <K extends keyof T>(\n\t\tkey: K,\n\t\texpireMillisecond: number,\n\t\tvalue: T[K],\n\t) => {\n\t\thasKeys[key as string] = 1;\n\t\tconst now = Date.now();\n\t\tsetExJobs[key as string] = {\n\t\t\texpire: expireMillisecond,\n\t\t\tvalue,\n\t\t};\n\t\tvalueCache[key as string] = {\n\t\t\texpire: expireMillisecond ? now + expireMillisecond : 0,\n\t\t\tvalue,\n\t\t};\n\t\trunSetExJobs();\n\t};\n\tconst getExWithCache = async <K extends keyof T>(key: K): Promise<T[K]> => {\n\t\tconst cacheValue = valueCache[key as string];\n\t\tif (cacheValue === void 0) {\n\t\t\tconst data = await getWithFormat(key);\n\t\t\tif (data === void 0 || data === null) {\n\t\t\t\treturn getDefaultValue(key);\n\t\t\t}\n\t\t\tif (data.expire && data.expire < Date.now()) {\n\t\t\t\tawait delWithCache(key);\n\t\t\t\treturn getDefaultValue(key);\n\t\t\t}\n\t\t\tif (data.value === void 0) {\n\t\t\t\tdata.value = getDefaultValue(key);\n\t\t\t}\n\t\t\tif (!ignoreCache) {\n\t\t\t\tvalueCache[key as string] = data;\n\t\t\t}\n\t\t\treturn data.value;\n\t\t}\n\t\tif (cacheValue.expire && cacheValue.expire < Date.now()) {\n\t\t\tdelWithCache(key);\n\t\t\treturn getDefaultValue(key);\n\t\t}\n\t\treturn cacheValue.value as T[K];\n\t};\n\tconst delWithCache = async <K extends keyof T>(key: K) => {\n\t\tdelete hasKeys[key as string];\n\t\tdelete valueCache[key as string];\n\t\tdelete setExJobs[key as string];\n\t\tawait delDb(key);\n\t};\n\tconst assign = async <K extends keyof T>(\n\t\tkey: K,\n\t\tvalue: Partial<T[K]>,\n\t): Promise<Partial<T[K]>> => {\n\t\treturn assignEx(key, 0, value);\n\t};\n\tconst assignEx = async <K extends keyof T>(\n\t\tkey: K,\n\t\texpireMillisecond: number,\n\t\tvalue: Partial<T[K]>,\n\t): Promise<Partial<T[K]>> => {\n\t\tconst old = (await getExWithCache(key)) || getDefaultValue(key);\n\t\tif (!old) {\n\t\t\tthrow new Error(\"[NanoIndexed.assign] assign need is object\");\n\t\t}\n\t\tconst next = Object.assign(old, value) as T[K];\n\t\tsetExWithCache(key, expireMillisecond, next);\n\t\treturn next;\n\t};\n\n\tconst getAll = async () => {\n\t\tconst keys = Object.keys({\n\t\t\t...defaultValue,\n\t\t\t...hasKeys,\n\t\t}) as (keyof T)[];\n\t\tconst out = {} as T;\n\t\tfor (const key of keys) {\n\t\t\tconst value = await getExWithCache(key);\n\t\t\tout[key] = value;\n\t\t}\n\t\treturn out;\n\t};\n\n\tconst flushDb = async () => {\n\t\tconst keys = Object.keys({\n\t\t\t...defaultValue,\n\t\t\t...hasKeys,\n\t\t}) as (keyof T)[];\n\t\tfor (const key of keys) {\n\t\t\tawait delWithCache(key);\n\t\t}\n\t};\n\n\t// assignEx -> getEx + setEx\n\t// assign -> assignEx\n\t// set -> setExWithCache -> setWithFormat -> setDb\n\t// get -> getExWithCache -> getWithFormat -> getDb\n\treturn {\n\t\tget: getExWithCache,\n\t\tsetEx: setExWithCache,\n\t\tset,\n\t\tassign,\n\t\tassignEx,\n\t\tdel: delWithCache,\n\t\tgetAll,\n\t\tflushDb,\n\t\tgetDefaultValue,\n\t};\n}\n",
  "export const isHaveIndexedDb =\n\ttypeof (window || global) !== \"undefined\" &&\n\ttypeof (window || global).indexedDB !== \"undefined\";\n\nif (!isHaveIndexedDb) {\n\tconsole.error(\n\t\t\"[indexed-redis] [WARN] Your browser not have indexedDB, Now use localStorage.\",\n\t);\n}\n",
  "import { debounce } from \"throttle-debounce\";\nimport { isHaveIndexedDb } from \"./is-have-indexed-db\";\n\ninterface IndexedRedisOptions<T> {\n\tdbName: string;\n\tdefaultValue: T;\n\toptimisticDelay?: number;\n\tignoreCache?: boolean;\n\tonlyUseLocalStorage?: boolean;\n\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\tsetFormat?: (value: any) => any | Promise<any>;\n\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\tgetFormat?: (value: any) => any | Promise<any>;\n}\n\nconst baseFormat = (v: unknown) => v;\n\nexport type IndexedRedis<T> = ReturnType<typeof IndexedRedis<T>>;\n\nexport function IndexedRedis<T>(options: IndexedRedisOptions<T>) {\n\tconst dbName = options.dbName;\n\tconst defaultValue = options.defaultValue;\n\tconst optimisticDelay = options.optimisticDelay || 500;\n\tconst isUseIndexedDb = options.onlyUseLocalStorage ? false : isHaveIndexedDb;\n\tconst setFormat = options.setFormat || baseFormat;\n\tconst getFormat = options.getFormat || baseFormat;\n\tconst ignoreCache = options.ignoreCache || false;\n\tconst oldKeys = localStorage.getItem(`[${dbName}-keys]`);\n\tlet hasKeys: Record<string, number> = {};\n\tif (oldKeys) {\n\t\ttry {\n\t\t\thasKeys = JSON.parse(oldKeys);\n\t\t} catch (error) {\n\t\t\t//\n\t\t}\n\t}\n\n\tconst valueCache: Record<string, { expire: number; value: unknown }> = {};\n\tconst setExJobs: Record<string, { expire: number; value: unknown }> = {};\n\tlet db: IDBDatabase | undefined;\n\tlet initd = localStorage.getItem(`indexed-redis-initd-${dbName}`) === \"true\";\n\n\tconst getDefaultValue = <K extends keyof T>(key: K): T[K] => {\n\t\tif (defaultValue[key] === void 0) {\n\t\t\treturn defaultValue[key];\n\t\t}\n\t\treturn JSON.parse(JSON.stringify(defaultValue[key]));\n\t};\n\n\tconst runSetExJobs = debounce(optimisticDelay, () => {\n\t\tconst keys = Object.keys(setExJobs);\n\t\tif (keys.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tkeys.forEach((key) => {\n\t\t\tconst job = setExJobs[key];\n\t\t\tif (job) {\n\t\t\t\tsetWithFormat(key, job);\n\t\t\t}\n\t\t\tdelete setExJobs[key];\n\t\t});\n\t});\n\n\tconst saveOtherLocal = () => {\n\t\tlocalStorage.setItem(`[${dbName}-keys]`, JSON.stringify(hasKeys));\n\t};\n\n\tconst initDb = async () => {\n\t\tif (db) {\n\t\t\treturn;\n\t\t}\n\t\tif (!initd) {\n\t\t\tlocalStorage.setItem(`indexed-redis-initd-${dbName}`, \"true\");\n\t\t\tinitd = true;\n\t\t}\n\t\tif (!isUseIndexedDb) {\n\t\t\treturn;\n\t\t}\n\t\treturn new Promise((res) => {\n\t\t\tif (!db) {\n\t\t\t\tconst reqDb = window.indexedDB.open(dbName);\n\t\t\t\treqDb.onerror = console.error;\n\t\t\t\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\t\t\t\treqDb.onsuccess = (event: any) => {\n\t\t\t\t\tif (!db) {\n\t\t\t\t\t\tdb = event.target.result;\n\t\t\t\t\t}\n\t\t\t\t\tres(void 0);\n\t\t\t\t};\n\t\t\t\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\t\t\t\treqDb.onupgradeneeded = (event: any) => {\n\t\t\t\t\tif (!db) {\n\t\t\t\t\t\tdb = event.target.result;\n\t\t\t\t\t}\n\t\t\t\t\tdb?.createObjectStore(dbName, {\n\t\t\t\t\t\tautoIncrement: false,\n\t\t\t\t\t\tkeyPath: \"key\",\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tres(void 0);\n\t\t\t}\n\t\t});\n\t};\n\tconst delDb = async <K extends keyof T>(key: K) => {\n\t\tawait initDb();\n\t\tsaveOtherLocal();\n\t\tif (!isUseIndexedDb) {\n\t\t\tlocalStorage.removeItem(`[${dbName}] ${key as string}`);\n\t\t}\n\t\treturn new Promise((res) => {\n\t\t\tif (db) {\n\t\t\t\tconst transaction = db.transaction([dbName], \"readwrite\");\n\t\t\t\tconst objectStore = transaction.objectStore(dbName);\n\t\t\t\tconst request = objectStore.delete(key as string);\n\t\t\t\trequest.onerror = (err) => {\n\t\t\t\t\tconsole.error(err);\n\t\t\t\t\tres(void 0);\n\t\t\t\t};\n\t\t\t\trequest.onsuccess = () => {\n\t\t\t\t\tres(void 0);\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tres(void 0);\n\t\t\t}\n\t\t});\n\t};\n\tconst setDb = async (key: string, value: unknown) => {\n\t\tawait initDb();\n\t\tsaveOtherLocal();\n\t\tif (!isUseIndexedDb) {\n\t\t\tlocalStorage.setItem(\n\t\t\t\t`[${dbName}] ${key as string}`,\n\t\t\t\tJSON.stringify({\n\t\t\t\t\tpis: value,\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\t\treturn new Promise((res) => {\n\t\t\tif (db) {\n\t\t\t\tconst transaction = db.transaction([dbName], \"readwrite\");\n\t\t\t\tconst objectStore = transaction.objectStore(dbName);\n\t\t\t\tconst data = {\n\t\t\t\t\tkey: key,\n\t\t\t\t\tvalue: value,\n\t\t\t\t};\n\t\t\t\tconst request = objectStore.put(data);\n\t\t\t\trequest.onerror = (err) => {\n\t\t\t\t\tconsole.error(err);\n\t\t\t\t\tres(void 0);\n\t\t\t\t};\n\t\t\t\trequest.onsuccess = () => {\n\t\t\t\t\tres(void 0);\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tres(void 0);\n\t\t\t}\n\t\t});\n\t};\n\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\tconst getDb = async (key: any): Promise<any> => {\n\t\tawait initDb();\n\t\tif (!isUseIndexedDb) {\n\t\t\tconst old = localStorage.getItem(`[${dbName}] ${key as string}`);\n\t\t\tif (old === void 0 || old === null) {\n\t\t\t\treturn void 0;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\treturn JSON.parse(old as string).pis;\n\t\t\t} catch (error) {\n\t\t\t\tconsole.error(\"[indexed-redis] get error:\", error);\n\t\t\t\treturn void 0;\n\t\t\t}\n\t\t}\n\t\treturn new Promise((res) => {\n\t\t\tif (db) {\n\t\t\t\tconst transaction = db.transaction([dbName], \"readonly\");\n\t\t\t\tconst objectStore = transaction.objectStore(dbName);\n\t\t\t\tconst request = objectStore.get(key as string);\n\t\t\t\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\t\t\t\trequest.onsuccess = (event: any) => {\n\t\t\t\t\tconst data = event.target.result;\n\t\t\t\t\tif (data?.value === void 0) {\n\t\t\t\t\t\tres(void 0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tres(data?.value);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tres(void 0);\n\t\t\t}\n\t\t});\n\t};\n\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\tconst getWithFormat = async (key: any): Promise<any> => {\n\t\tconst data = await getDb(key);\n\t\tif (data === void 0 || data === null) {\n\t\t\treturn data;\n\t\t}\n\t\treturn Promise.resolve(getFormat(data));\n\t};\n\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\tconst setWithFormat = async (key: any, value: any) => {\n\t\tconst nextValue = await Promise.resolve(setFormat(value));\n\t\treturn setDb(key, nextValue);\n\t};\n\n\tconst set = (key: keyof T, value: T[keyof T]) => {\n\t\treturn setExWithCache(key, 0, value);\n\t};\n\n\t// use cache\n\tconst setExWithCache = async <K extends keyof T>(\n\t\tkey: K,\n\t\texpireMillisecond: number,\n\t\tvalue: T[K],\n\t) => {\n\t\thasKeys[key as string] = 1;\n\t\tconst now = Date.now();\n\t\tsetExJobs[key as string] = {\n\t\t\texpire: expireMillisecond,\n\t\t\tvalue,\n\t\t};\n\t\tvalueCache[key as string] = {\n\t\t\texpire: expireMillisecond ? now + expireMillisecond : 0,\n\t\t\tvalue,\n\t\t};\n\t\trunSetExJobs();\n\t};\n\tconst getExWithCache = async <K extends keyof T>(key: K): Promise<T[K]> => {\n\t\tconst cacheValue = valueCache[key as string];\n\t\tif (cacheValue === void 0) {\n\t\t\tconst data = await getWithFormat(key);\n\t\t\tif (data === void 0 || data === null) {\n\t\t\t\treturn getDefaultValue(key);\n\t\t\t}\n\t\t\tif (data.expire && data.expire < Date.now()) {\n\t\t\t\tawait delWithCache(key);\n\t\t\t\treturn getDefaultValue(key);\n\t\t\t}\n\t\t\tif (data.value === void 0) {\n\t\t\t\tdata.value = getDefaultValue(key);\n\t\t\t}\n\t\t\tif (!ignoreCache) {\n\t\t\t\tvalueCache[key as string] = data;\n\t\t\t}\n\t\t\treturn data.value;\n\t\t}\n\t\tif (cacheValue.expire && cacheValue.expire < Date.now()) {\n\t\t\tdelWithCache(key);\n\t\t\treturn getDefaultValue(key);\n\t\t}\n\t\treturn cacheValue.value as T[K];\n\t};\n\tconst delWithCache = async <K extends keyof T>(key: K) => {\n\t\tdelete hasKeys[key as string];\n\t\tdelete valueCache[key as string];\n\t\tdelete setExJobs[key as string];\n\t\tawait delDb(key);\n\t};\n\tconst assign = async <K extends keyof T>(\n\t\tkey: K,\n\t\tvalue: Partial<T[K]>,\n\t): Promise<Partial<T[K]>> => {\n\t\treturn assignEx(key, 0, value);\n\t};\n\tconst assignEx = async <K extends keyof T>(\n\t\tkey: K,\n\t\texpireMillisecond: number,\n\t\tvalue: Partial<T[K]>,\n\t): Promise<Partial<T[K]>> => {\n\t\tconst old = (await getExWithCache(key)) || getDefaultValue(key);\n\t\tif (!old) {\n\t\t\tthrow new Error(\"[NanoIndexed.assign] assign need is object\");\n\t\t}\n\t\tconst next = Object.assign(old, value) as T[K];\n\t\tsetExWithCache(key, expireMillisecond, next);\n\t\treturn next;\n\t};\n\n\tconst getAll = async () => {\n\t\tconst keys = Object.keys({\n\t\t\t...defaultValue,\n\t\t\t...hasKeys,\n\t\t}) as (keyof T)[];\n\t\tconst out = {} as T;\n\t\tfor (const key of keys) {\n\t\t\tconst value = await getExWithCache(key);\n\t\t\tout[key] = value;\n\t\t}\n\t\treturn out;\n\t};\n\n\tconst flushDb = async () => {\n\t\tconst keys = Object.keys({\n\t\t\t...defaultValue,\n\t\t\t...hasKeys,\n\t\t}) as (keyof T)[];\n\t\tfor (const key of keys) {\n\t\t\tawait delWithCache(key);\n\t\t}\n\t};\n\n\t// assignEx -> getEx + setEx\n\t// assign -> assignEx\n\t// set -> setExWithCache -> setWithFormat -> setDb\n\t// get -> getExWithCache -> getWithFormat -> getDb\n\treturn {\n\t\tget: getExWithCache,\n\t\tsetEx: setExWithCache,\n\t\tset,\n\t\tassign,\n\t\tassignEx,\n\t\tdel: delWithCache,\n\t\tgetAll,\n\t\tflushDb,\n\t\tgetDefaultValue,\n\t};\n}\n"
  ],
  "mappings": ";AAAA;;;ACAO,IAAM,0BACJ,UAAU,YAAY,uBACtB,UAAU,QAAQ,cAAc;AAEzC,KAAK,iBAAiB;AACrB,UAAQ,MACP,+EACD;AACD;",
  "debugId": "BC46FE6303066C8064756e2164756e21",
  "names": []
}
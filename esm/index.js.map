{
  "version": 3,
  "sources": ["../lib/index.ts", "../lib/is-have-indexed-db.ts", "../lib/index.ts"],
  "sourcesContent": [
    "import { debounce } from \"throttle-debounce\";\nimport { isHaveIndexedDb } from \"./is-have-indexed-db\";\n\ninterface IndexedRedisOptions<T> {\n\tdbName: string;\n\tdefaultValue: T;\n\toptimisticDelay?: number;\n}\n\n// aaa\n\nexport class IndexedRedis<T> {\n\tprivate dbName: string;\n\tprivate defaultValue: T;\n\tprivate optimisticDelay: number;\n\tprivate db?: IDBDatabase;\n\tprivate lastClearTime: number;\n\tprivate valueCache: Record<string, { expire: number; value: unknown }>;\n\tprivate setExJobs: Record<string, { expire: number; value: unknown }>;\n\tprivate initd: boolean;\n\tprivate runSetExJobs: () => void;\n\tprivate reduceValueCache = 0;\n\n\tconstructor({\n\t\tdbName,\n\t\tdefaultValue,\n\t\toptimisticDelay = 500,\n\t}: IndexedRedisOptions<T>) {\n\t\tthis.dbName = dbName;\n\t\tthis.defaultValue = defaultValue;\n\t\tthis.optimisticDelay = optimisticDelay;\n\t\tthis.lastClearTime = 0;\n\t\tthis.valueCache = {};\n\t\tthis.setExJobs = {};\n\t\tthis.initd =\n\t\t\tlocalStorage.getItem(`indexed-redis-initd-${dbName}`) === \"true\";\n\n\t\tthis.runSetExJobs = debounce(this.optimisticDelay, () => {\n\t\t\tthis.reduceValueCache++;\n\t\t\tif (this.reduceValueCache > 200) {\n\t\t\t\tthis.reduceValueCache = 0;\n\t\t\t\tObject.keys(this.valueCache).forEach((k) => {\n\t\t\t\t\tconst v = this.valueCache[k];\n\t\t\t\t\tif (v.expire && v.expire < Date.now()) {\n\t\t\t\t\t\tdelete this.valueCache[k];\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tconst keys = Object.keys(this.valueCache);\n\t\t\t\tif (keys.length > 500) {\n\t\t\t\t\tthis.valueCache = {};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst keys = Object.keys(this.setExJobs);\n\t\t\tif (keys.length === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tkeys.forEach((key) => {\n\t\t\t\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\t\t\t\tconst job = this.setExJobs[key] as any;\n\t\t\t\tif (job) {\n\t\t\t\t\tthis.baseSetEx(key as keyof T, job.expire, job.value);\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.setExJobs = {};\n\t\t});\n\t}\n\n\tprivate initDb = async () => {\n\t\tif (!this.initd) {\n\t\t\tfor (const key of Object.keys(this.defaultValue as object)) {\n\t\t\t\tawait this.baseSetEx(\n\t\t\t\t\tkey as keyof T,\n\t\t\t\t\t0,\n\t\t\t\t\tthis.defaultValue[key as keyof T],\n\t\t\t\t\ttrue,\n\t\t\t\t);\n\t\t\t}\n\t\t\tlocalStorage.setItem(`indexed-redis-initd-${this.dbName}`, \"true\");\n\t\t\tthis.initd = true;\n\t\t}\n\t\tif (!isHaveIndexedDb) {\n\t\t\treturn;\n\t\t}\n\t\treturn new Promise((res) => {\n\t\t\tif (!this.db) {\n\t\t\t\tconst reqDb = window.indexedDB.open(\"indexed-redis-\" + this.dbName);\n\t\t\t\treqDb.onerror = console.error;\n\t\t\t\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\t\t\t\treqDb.onsuccess = (event: any) => {\n\t\t\t\t\tif (!this.db) {\n\t\t\t\t\t\tthis.db = event.target.result;\n\t\t\t\t\t}\n\t\t\t\t\tres(void 0);\n\t\t\t\t};\n\t\t\t\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\t\t\t\treqDb.onupgradeneeded = (event: any) => {\n\t\t\t\t\tif (!this.db) {\n\t\t\t\t\t\tthis.db = event.target.result;\n\t\t\t\t\t}\n\t\t\t\t\tthis.db?.createObjectStore(this.dbName, {\n\t\t\t\t\t\tautoIncrement: false,\n\t\t\t\t\t\tkeyPath: \"key\",\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tres(void 0);\n\t\t\t}\n\t\t});\n\t};\n\n\tpublic clearExpiredItems = async (force?: boolean) => {\n\t\tconst now = Date.now();\n\t\tif (\n\t\t\t!force &&\n\t\t\tthis.lastClearTime &&\n\t\t\tnow - this.lastClearTime < 60 * 1000 * 5\n\t\t) {\n\t\t\t// Less than 5 minutes has passed since the last clear, so we do nothing\n\t\t\treturn;\n\t\t}\n\t\tthis.lastClearTime = now;\n\t\tawait this.getAll();\n\t};\n\n\tprivate baseSetEx = async <K extends keyof T>(\n\t\tkey: K,\n\t\texpireMillisecond: number,\n\t\tvalue: T[K],\n\t\tisInit?: boolean,\n\t) => {\n\t\tif (!this.db && !isInit) {\n\t\t\tawait this.initDb();\n\t\t}\n\t\tthis.clearExpiredItems();\n\t\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\t\tconst theObj = value as any;\n\t\tif (!isHaveIndexedDb) {\n\t\t\treturn new Promise((res) => {\n\t\t\t\tlocalStorage.setItem(\n\t\t\t\t\t`[${this.dbName}] ${key as string}`,\n\t\t\t\t\tJSON.stringify({\n\t\t\t\t\t\tvalue: theObj,\n\t\t\t\t\t\texpire: expireMillisecond ? Date.now() + expireMillisecond : 0,\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t\tres(value);\n\t\t\t});\n\t\t}\n\n\t\treturn new Promise((res) => {\n\t\t\tif (this.db?.objectStoreNames.contains(this.dbName)) {\n\t\t\t\tconst transaction = this.db.transaction([this.dbName], \"readwrite\");\n\t\t\t\tconst objectStore = transaction.objectStore(this.dbName);\n\t\t\t\tconst data = {\n\t\t\t\t\tkey: key,\n\t\t\t\t\tvalue: theObj,\n\t\t\t\t\texpire: expireMillisecond ? Date.now() + expireMillisecond : 0,\n\t\t\t\t};\n\t\t\t\tconst request = objectStore.put(data);\n\t\t\t\trequest.onerror = (err) => {\n\t\t\t\t\tconsole.error(err);\n\t\t\t\t\tres(value);\n\t\t\t\t};\n\t\t\t\trequest.onsuccess = () => {\n\t\t\t\t\tres(value);\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tres(value);\n\t\t\t}\n\t\t});\n\t};\n\n\tprivate baseAssignEx = async <K extends keyof T>(\n\t\tkey: K,\n\t\texpireMillisecond: number,\n\t\tvalue: Partial<T[K]>,\n\t): Promise<Partial<T[K]>> => {\n\t\tif (typeof value !== \"object\") {\n\t\t\tthrow new Error(\"[NanoIndexed.assign] assign need is object\");\n\t\t}\n\t\tconst old = await this.get(key);\n\t\tif (!old) {\n\t\t\tthrow new Error(\"[NanoIndexed.assign] assign need has old object\");\n\t\t}\n\t\tif (typeof old !== \"object\") {\n\t\t\treturn old;\n\t\t}\n\t\tconst next = Object.assign(old, value);\n\t\tthis.setEx(key, expireMillisecond, next);\n\t\treturn next;\n\t};\n\n\tprivate getCacheValue = (key: string) => {\n\t\tconst old = this.valueCache[key];\n\t\tif (old) {\n\t\t\tif (old.expire && old.expire < Date.now()) {\n\t\t\t\tdelete this.valueCache[key];\n\t\t\t\treturn void 0;\n\t\t\t}\n\t\t\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\t\t\treturn old.value as any;\n\t\t}\n\t};\n\n\tprivate baseGet = async <K extends keyof T>(key: K): Promise<T[K]> => {\n\t\tif (!this.db) {\n\t\t\tawait this.initDb();\n\t\t}\n\t\tconst cacheValue = this.getCacheValue(key as string);\n\t\tif (cacheValue !== void 0) {\n\t\t\treturn cacheValue;\n\t\t}\n\t\tthis.clearExpiredItems();\n\t\tif (!isHaveIndexedDb) {\n\t\t\treturn new Promise((res) => {\n\t\t\t\tlet data = localStorage.getItem(`[${this.dbName}] ${key as string}`);\n\t\t\t\tif (data) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst obj = JSON.parse(data);\n\t\t\t\t\t\tdata = obj?.value;\n\t\t\t\t\t\tif (obj?.expire && obj.expire < Date.now()) {\n\t\t\t\t\t\t\tlocalStorage.removeItem(`[${this.dbName}] ${key as string}`);\n\t\t\t\t\t\t\tres(this.defaultValue[key]);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (err) {}\n\t\t\t\t}\n\t\t\t\tif (data === void 0 || data === null) {\n\t\t\t\t\tres(this.defaultValue[key]);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\t\t\t\tres(data as any);\n\t\t\t});\n\t\t}\n\n\t\treturn new Promise((res) => {\n\t\t\tif (this.db?.objectStoreNames.contains(this.dbName)) {\n\t\t\t\tconst transaction = this.db.transaction([this.dbName]);\n\t\t\t\tconst objectStore = transaction.objectStore(this.dbName);\n\t\t\t\tconst request = objectStore.get(key as string);\n\t\t\t\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\t\t\t\trequest.onsuccess = (event: any) => {\n\t\t\t\t\tconst data = event.target.result;\n\t\t\t\t\tres(data?.value);\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tres(this.defaultValue[key]);\n\t\t\t}\n\t\t});\n\t};\n\n\t// Public API\n\tpublic setEx = async <K extends keyof T>(\n\t\tkey: K,\n\t\texpireMillisecond: number,\n\t\tvalue: T[K],\n\t) => {\n\t\tconst now = Date.now();\n\t\tthis.setExJobs[key as string] = {\n\t\t\texpire: expireMillisecond,\n\t\t\tvalue,\n\t\t};\n\t\tthis.valueCache[key as string] = {\n\t\t\texpire: expireMillisecond ? now + expireMillisecond : 0,\n\t\t\tvalue,\n\t\t};\n\t\tthis.runSetExJobs();\n\t};\n\tpublic set = async <K extends keyof T>(key: K, value: T[K]) => {\n\t\treturn this.setEx(key, 0, value);\n\t};\n\tpublic assignEx = <K extends keyof T>(\n\t\tkey: K,\n\t\texpireMillisecond: number,\n\t\tvalue: Partial<T[K]>,\n\t): Promise<Partial<T[K]>> => {\n\t\treturn this.baseAssignEx(key, expireMillisecond, value);\n\t};\n\tpublic assign = <K extends keyof T>(\n\t\tkey: K,\n\t\tvalue: Partial<T[K]>,\n\t): Promise<Partial<T[K]>> => {\n\t\treturn this.baseAssignEx(key, 0, value);\n\t};\n\tpublic get = <K extends keyof T>(key: K): Promise<T[K]> => {\n\t\treturn this.baseGet(key);\n\t};\n\tpublic getAll = async (): Promise<Partial<T>> => {\n\t\tif (!this.db) {\n\t\t\tawait this.initDb();\n\t\t}\n\n\t\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\t\tconst out = {} as any;\n\t\tObject.keys(this.valueCache).forEach((key) => {\n\t\t\tconst v = this.valueCache[key];\n\t\t\tif (v.expire && v.expire < Date.now()) {\n\t\t\t\tdelete this.valueCache[key];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tout[key] = v.value;\n\t\t});\n\n\t\tif (!isHaveIndexedDb) {\n\t\t\treturn new Promise((res) => {\n\t\t\t\tconst now = Date.now();\n\t\t\t\tfor (let i = 0; i < localStorage.length; i++) {\n\t\t\t\t\tconst key = localStorage.key(i) || \"\";\n\t\t\t\t\tif (key.indexOf(`[${this.dbName}] `) === 0) {\n\t\t\t\t\t\tconst itemStr = localStorage.getItem(key);\n\t\t\t\t\t\tif (itemStr) {\n\t\t\t\t\t\t\tlet item: { expire: number; value: unknown };\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\titem = JSON.parse(itemStr);\n\t\t\t\t\t\t\t\tif (item.expire && now > item.expire) {\n\t\t\t\t\t\t\t\t\tlocalStorage.removeItem(key);\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst realKey = key.replace(`[${this.dbName}] `, \"\");\n\t\t\t\t\t\t\t\tif (out[realKey] === void 0) {\n\t\t\t\t\t\t\t\t\tout[realKey] = item.value;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t\t// eslint-disable-next-line no-continue\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\t\t\t\tres(out as any);\n\t\t\t});\n\t\t}\n\n\t\treturn new Promise((res) => {\n\t\t\tif (this.db?.objectStoreNames.contains(this.dbName)) {\n\t\t\t\tconst transaction = this.db.transaction([this.dbName]);\n\t\t\t\tconst objectStore = transaction.objectStore(this.dbName);\n\t\t\t\tconst request = objectStore.getAll();\n\t\t\t\tconst needDelete: string[] = [];\n\t\t\t\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\t\t\t\trequest.onsuccess = (event: any) => {\n\t\t\t\t\tconst data = event.target.result;\n\t\t\t\t\tconst now = Date.now();\n\t\t\t\t\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\t\t\t\t\tdata.forEach((v: any) => {\n\t\t\t\t\t\tif (v.expire && v.expire < now) {\n\t\t\t\t\t\t\tneedDelete.push(v.key);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (out[v.key] === void 0) {\n\t\t\t\t\t\t\tout[v.key] = v.value;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tres(out);\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tneedDelete.forEach((key) => {\n\t\t\t\t\t\t\tthis.del(key as keyof T);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tres(out);\n\t\t\t}\n\t\t});\n\t};\n\n\tpublic del = async <K extends keyof T>(key: K): Promise<T[K]> => {\n\t\tif (!this.db) {\n\t\t\tawait this.initDb();\n\t\t}\n\t\tdelete this.valueCache[key as string];\n\t\tif (!isHaveIndexedDb) {\n\t\t\treturn new Promise((res) => {\n\t\t\t\tlocalStorage.removeItem(`[${this.dbName}] ${key as string}`);\n\t\t\t\tres(this.defaultValue[key]);\n\t\t\t});\n\t\t}\n\t\treturn new Promise((res) => {\n\t\t\tif (this.db?.objectStoreNames.contains(this.dbName)) {\n\t\t\t\tconst transaction = this.db.transaction([this.dbName], \"readwrite\");\n\t\t\t\tconst objectStore = transaction.objectStore(this.dbName);\n\t\t\t\tconst request = objectStore.delete(key as \"string\");\n\t\t\t\trequest.onerror = (err) => {\n\t\t\t\t\tconsole.error(err);\n\t\t\t\t\tres(this.defaultValue[key]);\n\t\t\t\t};\n\t\t\t\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\t\t\t\trequest.onsuccess = res as any;\n\t\t\t} else {\n\t\t\t\tres(this.defaultValue[key]);\n\t\t\t}\n\t\t});\n\t};\n\n\tpublic flushDb = async () => {\n\t\tconst all = await this.getAll();\n\t\tawait Promise.all(\n\t\t\tObject.keys(all).map((key) => {\n\t\t\t\treturn this.del(key as keyof T);\n\t\t\t}),\n\t\t);\n\t};\n}\n",
  "export const isHaveIndexedDb =\n\ttypeof window !== \"undefined\" && typeof window.indexedDB !== \"undefined\";\n\nif (!isHaveIndexedDb) {\n\tconsole.error(\n\t\t\"[indexed-redis] [WARN] Your browser not have indexedDB, Now use localStorage.\",\n\t);\n}\n",
  "import { debounce } from \"throttle-debounce\";\nimport { isHaveIndexedDb } from \"./is-have-indexed-db\";\n\ninterface IndexedRedisOptions<T> {\n\tdbName: string;\n\tdefaultValue: T;\n\toptimisticDelay?: number;\n}\n\n// aaa\n\nexport class IndexedRedis<T> {\n\tprivate dbName: string;\n\tprivate defaultValue: T;\n\tprivate optimisticDelay: number;\n\tprivate db?: IDBDatabase;\n\tprivate lastClearTime: number;\n\tprivate valueCache: Record<string, { expire: number; value: unknown }>;\n\tprivate setExJobs: Record<string, { expire: number; value: unknown }>;\n\tprivate initd: boolean;\n\tprivate runSetExJobs: () => void;\n\tprivate reduceValueCache = 0;\n\n\tconstructor({\n\t\tdbName,\n\t\tdefaultValue,\n\t\toptimisticDelay = 500,\n\t}: IndexedRedisOptions<T>) {\n\t\tthis.dbName = dbName;\n\t\tthis.defaultValue = defaultValue;\n\t\tthis.optimisticDelay = optimisticDelay;\n\t\tthis.lastClearTime = 0;\n\t\tthis.valueCache = {};\n\t\tthis.setExJobs = {};\n\t\tthis.initd =\n\t\t\tlocalStorage.getItem(`indexed-redis-initd-${dbName}`) === \"true\";\n\n\t\tthis.runSetExJobs = debounce(this.optimisticDelay, () => {\n\t\t\tthis.reduceValueCache++;\n\t\t\tif (this.reduceValueCache > 200) {\n\t\t\t\tthis.reduceValueCache = 0;\n\t\t\t\tObject.keys(this.valueCache).forEach((k) => {\n\t\t\t\t\tconst v = this.valueCache[k];\n\t\t\t\t\tif (v.expire && v.expire < Date.now()) {\n\t\t\t\t\t\tdelete this.valueCache[k];\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tconst keys = Object.keys(this.valueCache);\n\t\t\t\tif (keys.length > 500) {\n\t\t\t\t\tthis.valueCache = {};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst keys = Object.keys(this.setExJobs);\n\t\t\tif (keys.length === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tkeys.forEach((key) => {\n\t\t\t\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\t\t\t\tconst job = this.setExJobs[key] as any;\n\t\t\t\tif (job) {\n\t\t\t\t\tthis.baseSetEx(key as keyof T, job.expire, job.value);\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.setExJobs = {};\n\t\t});\n\t}\n\n\tprivate initDb = async () => {\n\t\tif (!this.initd) {\n\t\t\tfor (const key of Object.keys(this.defaultValue as object)) {\n\t\t\t\tawait this.baseSetEx(\n\t\t\t\t\tkey as keyof T,\n\t\t\t\t\t0,\n\t\t\t\t\tthis.defaultValue[key as keyof T],\n\t\t\t\t\ttrue,\n\t\t\t\t);\n\t\t\t}\n\t\t\tlocalStorage.setItem(`indexed-redis-initd-${this.dbName}`, \"true\");\n\t\t\tthis.initd = true;\n\t\t}\n\t\tif (!isHaveIndexedDb) {\n\t\t\treturn;\n\t\t}\n\t\treturn new Promise((res) => {\n\t\t\tif (!this.db) {\n\t\t\t\tconst reqDb = window.indexedDB.open(\"indexed-redis-\" + this.dbName);\n\t\t\t\treqDb.onerror = console.error;\n\t\t\t\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\t\t\t\treqDb.onsuccess = (event: any) => {\n\t\t\t\t\tif (!this.db) {\n\t\t\t\t\t\tthis.db = event.target.result;\n\t\t\t\t\t}\n\t\t\t\t\tres(void 0);\n\t\t\t\t};\n\t\t\t\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\t\t\t\treqDb.onupgradeneeded = (event: any) => {\n\t\t\t\t\tif (!this.db) {\n\t\t\t\t\t\tthis.db = event.target.result;\n\t\t\t\t\t}\n\t\t\t\t\tthis.db?.createObjectStore(this.dbName, {\n\t\t\t\t\t\tautoIncrement: false,\n\t\t\t\t\t\tkeyPath: \"key\",\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tres(void 0);\n\t\t\t}\n\t\t});\n\t};\n\n\tpublic clearExpiredItems = async (force?: boolean) => {\n\t\tconst now = Date.now();\n\t\tif (\n\t\t\t!force &&\n\t\t\tthis.lastClearTime &&\n\t\t\tnow - this.lastClearTime < 60 * 1000 * 5\n\t\t) {\n\t\t\t// Less than 5 minutes has passed since the last clear, so we do nothing\n\t\t\treturn;\n\t\t}\n\t\tthis.lastClearTime = now;\n\t\tawait this.getAll();\n\t};\n\n\tprivate baseSetEx = async <K extends keyof T>(\n\t\tkey: K,\n\t\texpireMillisecond: number,\n\t\tvalue: T[K],\n\t\tisInit?: boolean,\n\t) => {\n\t\tif (!this.db && !isInit) {\n\t\t\tawait this.initDb();\n\t\t}\n\t\tthis.clearExpiredItems();\n\t\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\t\tconst theObj = value as any;\n\t\tif (!isHaveIndexedDb) {\n\t\t\treturn new Promise((res) => {\n\t\t\t\tlocalStorage.setItem(\n\t\t\t\t\t`[${this.dbName}] ${key as string}`,\n\t\t\t\t\tJSON.stringify({\n\t\t\t\t\t\tvalue: theObj,\n\t\t\t\t\t\texpire: expireMillisecond ? Date.now() + expireMillisecond : 0,\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t\tres(value);\n\t\t\t});\n\t\t}\n\n\t\treturn new Promise((res) => {\n\t\t\tif (this.db?.objectStoreNames.contains(this.dbName)) {\n\t\t\t\tconst transaction = this.db.transaction([this.dbName], \"readwrite\");\n\t\t\t\tconst objectStore = transaction.objectStore(this.dbName);\n\t\t\t\tconst data = {\n\t\t\t\t\tkey: key,\n\t\t\t\t\tvalue: theObj,\n\t\t\t\t\texpire: expireMillisecond ? Date.now() + expireMillisecond : 0,\n\t\t\t\t};\n\t\t\t\tconst request = objectStore.put(data);\n\t\t\t\trequest.onerror = (err) => {\n\t\t\t\t\tconsole.error(err);\n\t\t\t\t\tres(value);\n\t\t\t\t};\n\t\t\t\trequest.onsuccess = () => {\n\t\t\t\t\tres(value);\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tres(value);\n\t\t\t}\n\t\t});\n\t};\n\n\tprivate baseAssignEx = async <K extends keyof T>(\n\t\tkey: K,\n\t\texpireMillisecond: number,\n\t\tvalue: Partial<T[K]>,\n\t): Promise<Partial<T[K]>> => {\n\t\tif (typeof value !== \"object\") {\n\t\t\tthrow new Error(\"[NanoIndexed.assign] assign need is object\");\n\t\t}\n\t\tconst old = await this.get(key);\n\t\tif (!old) {\n\t\t\tthrow new Error(\"[NanoIndexed.assign] assign need has old object\");\n\t\t}\n\t\tif (typeof old !== \"object\") {\n\t\t\treturn old;\n\t\t}\n\t\tconst next = Object.assign(old, value);\n\t\tthis.setEx(key, expireMillisecond, next);\n\t\treturn next;\n\t};\n\n\tprivate getCacheValue = (key: string) => {\n\t\tconst old = this.valueCache[key];\n\t\tif (old) {\n\t\t\tif (old.expire && old.expire < Date.now()) {\n\t\t\t\tdelete this.valueCache[key];\n\t\t\t\treturn void 0;\n\t\t\t}\n\t\t\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\t\t\treturn old.value as any;\n\t\t}\n\t};\n\n\tprivate baseGet = async <K extends keyof T>(key: K): Promise<T[K]> => {\n\t\tif (!this.db) {\n\t\t\tawait this.initDb();\n\t\t}\n\t\tconst cacheValue = this.getCacheValue(key as string);\n\t\tif (cacheValue !== void 0) {\n\t\t\treturn cacheValue;\n\t\t}\n\t\tthis.clearExpiredItems();\n\t\tif (!isHaveIndexedDb) {\n\t\t\treturn new Promise((res) => {\n\t\t\t\tlet data = localStorage.getItem(`[${this.dbName}] ${key as string}`);\n\t\t\t\tif (data) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst obj = JSON.parse(data);\n\t\t\t\t\t\tdata = obj?.value;\n\t\t\t\t\t\tif (obj?.expire && obj.expire < Date.now()) {\n\t\t\t\t\t\t\tlocalStorage.removeItem(`[${this.dbName}] ${key as string}`);\n\t\t\t\t\t\t\tres(this.defaultValue[key]);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (err) {}\n\t\t\t\t}\n\t\t\t\tif (data === void 0 || data === null) {\n\t\t\t\t\tres(this.defaultValue[key]);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\t\t\t\tres(data as any);\n\t\t\t});\n\t\t}\n\n\t\treturn new Promise((res) => {\n\t\t\tif (this.db?.objectStoreNames.contains(this.dbName)) {\n\t\t\t\tconst transaction = this.db.transaction([this.dbName]);\n\t\t\t\tconst objectStore = transaction.objectStore(this.dbName);\n\t\t\t\tconst request = objectStore.get(key as string);\n\t\t\t\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\t\t\t\trequest.onsuccess = (event: any) => {\n\t\t\t\t\tconst data = event.target.result;\n\t\t\t\t\tres(data?.value);\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tres(this.defaultValue[key]);\n\t\t\t}\n\t\t});\n\t};\n\n\t// Public API\n\tpublic setEx = async <K extends keyof T>(\n\t\tkey: K,\n\t\texpireMillisecond: number,\n\t\tvalue: T[K],\n\t) => {\n\t\tconst now = Date.now();\n\t\tthis.setExJobs[key as string] = {\n\t\t\texpire: expireMillisecond,\n\t\t\tvalue,\n\t\t};\n\t\tthis.valueCache[key as string] = {\n\t\t\texpire: expireMillisecond ? now + expireMillisecond : 0,\n\t\t\tvalue,\n\t\t};\n\t\tthis.runSetExJobs();\n\t};\n\tpublic set = async <K extends keyof T>(key: K, value: T[K]) => {\n\t\treturn this.setEx(key, 0, value);\n\t};\n\tpublic assignEx = <K extends keyof T>(\n\t\tkey: K,\n\t\texpireMillisecond: number,\n\t\tvalue: Partial<T[K]>,\n\t): Promise<Partial<T[K]>> => {\n\t\treturn this.baseAssignEx(key, expireMillisecond, value);\n\t};\n\tpublic assign = <K extends keyof T>(\n\t\tkey: K,\n\t\tvalue: Partial<T[K]>,\n\t): Promise<Partial<T[K]>> => {\n\t\treturn this.baseAssignEx(key, 0, value);\n\t};\n\tpublic get = <K extends keyof T>(key: K): Promise<T[K]> => {\n\t\treturn this.baseGet(key);\n\t};\n\tpublic getAll = async (): Promise<Partial<T>> => {\n\t\tif (!this.db) {\n\t\t\tawait this.initDb();\n\t\t}\n\n\t\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\t\tconst out = {} as any;\n\t\tObject.keys(this.valueCache).forEach((key) => {\n\t\t\tconst v = this.valueCache[key];\n\t\t\tif (v.expire && v.expire < Date.now()) {\n\t\t\t\tdelete this.valueCache[key];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tout[key] = v.value;\n\t\t});\n\n\t\tif (!isHaveIndexedDb) {\n\t\t\treturn new Promise((res) => {\n\t\t\t\tconst now = Date.now();\n\t\t\t\tfor (let i = 0; i < localStorage.length; i++) {\n\t\t\t\t\tconst key = localStorage.key(i) || \"\";\n\t\t\t\t\tif (key.indexOf(`[${this.dbName}] `) === 0) {\n\t\t\t\t\t\tconst itemStr = localStorage.getItem(key);\n\t\t\t\t\t\tif (itemStr) {\n\t\t\t\t\t\t\tlet item: { expire: number; value: unknown };\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\titem = JSON.parse(itemStr);\n\t\t\t\t\t\t\t\tif (item.expire && now > item.expire) {\n\t\t\t\t\t\t\t\t\tlocalStorage.removeItem(key);\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst realKey = key.replace(`[${this.dbName}] `, \"\");\n\t\t\t\t\t\t\t\tif (out[realKey] === void 0) {\n\t\t\t\t\t\t\t\t\tout[realKey] = item.value;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t\t// eslint-disable-next-line no-continue\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\t\t\t\tres(out as any);\n\t\t\t});\n\t\t}\n\n\t\treturn new Promise((res) => {\n\t\t\tif (this.db?.objectStoreNames.contains(this.dbName)) {\n\t\t\t\tconst transaction = this.db.transaction([this.dbName]);\n\t\t\t\tconst objectStore = transaction.objectStore(this.dbName);\n\t\t\t\tconst request = objectStore.getAll();\n\t\t\t\tconst needDelete: string[] = [];\n\t\t\t\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\t\t\t\trequest.onsuccess = (event: any) => {\n\t\t\t\t\tconst data = event.target.result;\n\t\t\t\t\tconst now = Date.now();\n\t\t\t\t\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\t\t\t\t\tdata.forEach((v: any) => {\n\t\t\t\t\t\tif (v.expire && v.expire < now) {\n\t\t\t\t\t\t\tneedDelete.push(v.key);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (out[v.key] === void 0) {\n\t\t\t\t\t\t\tout[v.key] = v.value;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tres(out);\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tneedDelete.forEach((key) => {\n\t\t\t\t\t\t\tthis.del(key as keyof T);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tres(out);\n\t\t\t}\n\t\t});\n\t};\n\n\tpublic del = async <K extends keyof T>(key: K): Promise<T[K]> => {\n\t\tif (!this.db) {\n\t\t\tawait this.initDb();\n\t\t}\n\t\tdelete this.valueCache[key as string];\n\t\tif (!isHaveIndexedDb) {\n\t\t\treturn new Promise((res) => {\n\t\t\t\tlocalStorage.removeItem(`[${this.dbName}] ${key as string}`);\n\t\t\t\tres(this.defaultValue[key]);\n\t\t\t});\n\t\t}\n\t\treturn new Promise((res) => {\n\t\t\tif (this.db?.objectStoreNames.contains(this.dbName)) {\n\t\t\t\tconst transaction = this.db.transaction([this.dbName], \"readwrite\");\n\t\t\t\tconst objectStore = transaction.objectStore(this.dbName);\n\t\t\t\tconst request = objectStore.delete(key as \"string\");\n\t\t\t\trequest.onerror = (err) => {\n\t\t\t\t\tconsole.error(err);\n\t\t\t\t\tres(this.defaultValue[key]);\n\t\t\t\t};\n\t\t\t\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\t\t\t\trequest.onsuccess = res as any;\n\t\t\t} else {\n\t\t\t\tres(this.defaultValue[key]);\n\t\t\t}\n\t\t});\n\t};\n\n\tpublic flushDb = async () => {\n\t\tconst all = await this.getAll();\n\t\tawait Promise.all(\n\t\t\tObject.keys(all).map((key) => {\n\t\t\t\treturn this.del(key as keyof T);\n\t\t\t}),\n\t\t);\n\t};\n}\n"
  ],
  "mappings": ";AAAA;;;ACAO,IAAM,yBACL,WAAW,sBAAsB,OAAO,cAAc;AAE9D,KAAK,iBAAiB;AACrB,UAAQ,MACP,+EACD;AACD;",
  "debugId": "2D957A400A9404AF64756e2164756e21",
  "names": []
}
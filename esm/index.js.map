{
  "version": 3,
  "sources": ["../node_modules/throttle-debounce/esm/index.js", "../lib/index.ts"],
  "sourcesContent": [
    "/* eslint-disable no-undefined,no-param-reassign,no-shadow */\n\n/**\n * Throttle execution of a function. Especially useful for rate limiting\n * execution of handlers on events like resize and scroll.\n *\n * @param {number} delay -                  A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher)\n *                                            are most useful.\n * @param {Function} callback -               A function to be executed after delay milliseconds. The `this` context and all arguments are passed through,\n *                                            as-is, to `callback` when the throttled-function is executed.\n * @param {object} [options] -              An object to configure options.\n * @param {boolean} [options.noTrailing] -   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds\n *                                            while the throttled-function is being called. If noTrailing is false or unspecified, callback will be executed\n *                                            one final time after the last throttled-function call. (After the throttled-function has not been called for\n *                                            `delay` milliseconds, the internal counter is reset).\n * @param {boolean} [options.noLeading] -   Optional, defaults to false. If noLeading is false, the first throttled-function call will execute callback\n *                                            immediately. If noLeading is true, the first the callback execution will be skipped. It should be noted that\n *                                            callback will never executed if both noLeading = true and noTrailing = true.\n * @param {boolean} [options.debounceMode] - If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is\n *                                            false (at end), schedule `callback` to execute after `delay` ms.\n *\n * @returns {Function} A new, throttled, function.\n */\nfunction throttle (delay, callback, options) {\n  var _ref = options || {},\n      _ref$noTrailing = _ref.noTrailing,\n      noTrailing = _ref$noTrailing === void 0 ? false : _ref$noTrailing,\n      _ref$noLeading = _ref.noLeading,\n      noLeading = _ref$noLeading === void 0 ? false : _ref$noLeading,\n      _ref$debounceMode = _ref.debounceMode,\n      debounceMode = _ref$debounceMode === void 0 ? undefined : _ref$debounceMode;\n  /*\n   * After wrapper has stopped being called, this timeout ensures that\n   * `callback` is executed at the proper times in `throttle` and `end`\n   * debounce modes.\n   */\n\n\n  var timeoutID;\n  var cancelled = false; // Keep track of the last time `callback` was executed.\n\n  var lastExec = 0; // Function to clear existing timeout\n\n  function clearExistingTimeout() {\n    if (timeoutID) {\n      clearTimeout(timeoutID);\n    }\n  } // Function to cancel next exec\n\n\n  function cancel(options) {\n    var _ref2 = options || {},\n        _ref2$upcomingOnly = _ref2.upcomingOnly,\n        upcomingOnly = _ref2$upcomingOnly === void 0 ? false : _ref2$upcomingOnly;\n\n    clearExistingTimeout();\n    cancelled = !upcomingOnly;\n  }\n  /*\n   * The `wrapper` function encapsulates all of the throttling / debouncing\n   * functionality and when executed will limit the rate at which `callback`\n   * is executed.\n   */\n\n\n  function wrapper() {\n    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {\n      arguments_[_key] = arguments[_key];\n    }\n\n    var self = this;\n    var elapsed = Date.now() - lastExec;\n\n    if (cancelled) {\n      return;\n    } // Execute `callback` and update the `lastExec` timestamp.\n\n\n    function exec() {\n      lastExec = Date.now();\n      callback.apply(self, arguments_);\n    }\n    /*\n     * If `debounceMode` is true (at begin) this is used to clear the flag\n     * to allow future `callback` executions.\n     */\n\n\n    function clear() {\n      timeoutID = undefined;\n    }\n\n    if (!noLeading && debounceMode && !timeoutID) {\n      /*\n       * Since `wrapper` is being called for the first time and\n       * `debounceMode` is true (at begin), execute `callback`\n       * and noLeading != true.\n       */\n      exec();\n    }\n\n    clearExistingTimeout();\n\n    if (debounceMode === undefined && elapsed > delay) {\n      if (noLeading) {\n        /*\n         * In throttle mode with noLeading, if `delay` time has\n         * been exceeded, update `lastExec` and schedule `callback`\n         * to execute after `delay` ms.\n         */\n        lastExec = Date.now();\n\n        if (!noTrailing) {\n          timeoutID = setTimeout(debounceMode ? clear : exec, delay);\n        }\n      } else {\n        /*\n         * In throttle mode without noLeading, if `delay` time has been exceeded, execute\n         * `callback`.\n         */\n        exec();\n      }\n    } else if (noTrailing !== true) {\n      /*\n       * In trailing throttle mode, since `delay` time has not been\n       * exceeded, schedule `callback` to execute `delay` ms after most\n       * recent execution.\n       *\n       * If `debounceMode` is true (at begin), schedule `clear` to execute\n       * after `delay` ms.\n       *\n       * If `debounceMode` is false (at end), schedule `callback` to\n       * execute after `delay` ms.\n       */\n      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);\n    }\n  }\n\n  wrapper.cancel = cancel; // Return the wrapper function.\n\n  return wrapper;\n}\n\n/* eslint-disable no-undefined */\n/**\n * Debounce execution of a function. Debouncing, unlike throttling,\n * guarantees that a function is only executed a single time, either at the\n * very beginning of a series of calls, or at the very end.\n *\n * @param {number} delay -               A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\n * @param {Function} callback -          A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,\n *                                        to `callback` when the debounced-function is executed.\n * @param {object} [options] -           An object to configure options.\n * @param {boolean} [options.atBegin] -  Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds\n *                                        after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.\n *                                        (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).\n *\n * @returns {Function} A new, debounced function.\n */\n\nfunction debounce (delay, callback, options) {\n  var _ref = options || {},\n      _ref$atBegin = _ref.atBegin,\n      atBegin = _ref$atBegin === void 0 ? false : _ref$atBegin;\n\n  return throttle(delay, callback, {\n    debounceMode: atBegin !== false\n  });\n}\n\nexport { debounce, throttle };\n//# sourceMappingURL=index.js.map\n",
  "import { debounce } from \"throttle-debounce\";\n\nexport type IndexedRedis<T> = ReturnType<typeof indexedRedis<T>>;\n\nexport const indexedRedis = <T>(dbName: string) => {\n\tconst isHaveIndexedDb = typeof window.indexedDB !== \"undefined\";\n\tif (!isHaveIndexedDb) {\n\t\tconsole.error(\n\t\t\t\"[nano-indexed] [Error] Your browser not have indexedDB, Now use localStorage.\",\n\t\t);\n\t}\n\tlet db: IDBDatabase;\n\tlet lastClearTime = 0;\n\tlet setExJobs: Record<string, { expire: number; value: unknown }> = {};\n\tlet valueCache: Record<string, { expire: number; value: unknown }> = {};\n\n\tconst initDb = () => {\n\t\treturn new Promise((res) => {\n\t\t\tif (!db) {\n\t\t\t\tconst reqDb = window.indexedDB.open(\"indexed-redis\");\n\t\t\t\treqDb.onerror = console.error;\n\t\t\t\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\t\t\t\treqDb.onsuccess = (event: any) => {\n\t\t\t\t\tif (!db) {\n\t\t\t\t\t\tdb = event.target.result;\n\t\t\t\t\t}\n\t\t\t\t\tres(void 0);\n\t\t\t\t};\n\t\t\t\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\t\t\t\treqDb.onupgradeneeded = (event: any) => {\n\t\t\t\t\tif (!db) {\n\t\t\t\t\t\tdb = event.target.result;\n\t\t\t\t\t}\n\t\t\t\t\tdb.createObjectStore(dbName, { autoIncrement: false });\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tres(void 0);\n\t\t\t}\n\t\t});\n\t};\n\n\tconst getCacheValue = (key: string) => {\n\t\tconst old = valueCache[key];\n\t\tif (old) {\n\t\t\tif (old.expire && old.expire < Date.now()) {\n\t\t\t\tdelete valueCache[key];\n\t\t\t\treturn void 0;\n\t\t\t}\n\t\t\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\t\t\treturn old.value as any;\n\t\t}\n\t};\n\n\tconst get = async <K extends keyof T>(key: K): Promise<T[K] | undefined> => {\n\t\tconst cacheValue = getCacheValue(key as string);\n\t\tif (cacheValue !== void 0) {\n\t\t\treturn cacheValue;\n\t\t}\n\t\tclearExpiredItems();\n\t\tif (!isHaveIndexedDb) {\n\t\t\treturn new Promise((res) => {\n\t\t\t\tlet data = localStorage.getItem(`[${dbName}] ${key as string}`);\n\t\t\t\tif (data) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst obj = JSON.parse(data);\n\t\t\t\t\t\tdata = obj?.value;\n\t\t\t\t\t\tif (obj?.expire && obj.expire < Date.now()) {\n\t\t\t\t\t\t\tlocalStorage.removeItem(`[${dbName}] ${key as string}`);\n\t\t\t\t\t\t\tres(void 0);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (err) {}\n\t\t\t\t}\n\t\t\t\tif (data === void 0 || data === null) {\n\t\t\t\t\tres(void 0);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\t\t\t\tres(data as any);\n\t\t\t});\n\t\t}\n\t\tif (!db) {\n\t\t\tawait initDb();\n\t\t}\n\t\treturn new Promise((res) => {\n\t\t\tif (db.objectStoreNames.contains(dbName)) {\n\t\t\t\tconst transaction = db.transaction([dbName]);\n\t\t\t\tconst objectStore = transaction.objectStore(dbName);\n\t\t\t\tconst request = objectStore.get(key as string);\n\t\t\t\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\t\t\t\trequest.onsuccess = (event: any) => {\n\t\t\t\t\tconst data = event.target.result;\n\t\t\t\t\tres(data?.value);\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tres(void 0);\n\t\t\t}\n\t\t});\n\t};\n\n\tconst getAll = async (): Promise<Partial<T>> => {\n\t\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\t\tconst out = {} as any;\n\t\tObject.keys(valueCache).forEach((key) => {\n\t\t\tconst v = valueCache[key];\n\t\t\tif (v.expire && v.expire < Date.now()) {\n\t\t\t\tdelete valueCache[key];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tout[key] = v.value;\n\t\t});\n\t\t// 获取所有数据\n\t\tif (!isHaveIndexedDb) {\n\t\t\treturn new Promise((res) => {\n\t\t\t\tconst now = Date.now();\n\t\t\t\tfor (let i = 0; i < localStorage.length; i++) {\n\t\t\t\t\tconst key = localStorage.key(i) || \"\";\n\t\t\t\t\tif (key.indexOf(`[${dbName}] `) === 0) {\n\t\t\t\t\t\tconst itemStr = localStorage.getItem(key);\n\t\t\t\t\t\tif (itemStr) {\n\t\t\t\t\t\t\tlet item: { expire: number; value: unknown };\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\titem = JSON.parse(itemStr);\n\t\t\t\t\t\t\t\tif (item.expire && now > item.expire) {\n\t\t\t\t\t\t\t\t\tlocalStorage.removeItem(key);\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst realKey = key.replace(`[${dbName}] `, \"\");\n\t\t\t\t\t\t\t\tif (out[realKey] === void 0) {\n\t\t\t\t\t\t\t\t\tout[realKey] = item.value;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t\t// eslint-disable-next-line no-continue\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\t\t\t\tres(out as any);\n\t\t\t});\n\t\t}\n\t\tif (!db) {\n\t\t\tawait initDb();\n\t\t}\n\t\treturn new Promise((res) => {\n\t\t\tif (db.objectStoreNames.contains(dbName)) {\n\t\t\t\tconst transaction = db.transaction([dbName]);\n\t\t\t\tconst objectStore = transaction.objectStore(dbName);\n\t\t\t\tconst request = objectStore.getAll();\n\t\t\t\tconst needDelete: string[] = [];\n\t\t\t\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\t\t\t\trequest.onsuccess = (event: any) => {\n\t\t\t\t\tconst data = event.target.result;\n\t\t\t\t\tconst now = Date.now();\n\t\t\t\t\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\t\t\t\t\tdata.forEach((v: any) => {\n\t\t\t\t\t\tObject.keys(v).forEach((key) => {\n\t\t\t\t\t\t\tif (key !== \"value\" && key !== \"expire\") {\n\t\t\t\t\t\t\t\tif (v.expire && v.expire < now) {\n\t\t\t\t\t\t\t\t\tneedDelete.push(key);\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (out[key] === void 0) {\n\t\t\t\t\t\t\t\t\tout[key] = v.value;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t\tres(out);\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tneedDelete.forEach((key) => {\n\t\t\t\t\t\t\tdel(key as keyof T);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tres(out);\n\t\t\t}\n\t\t});\n\t};\n\n\tconst setEx = async <K extends keyof T>(\n\t\tkey: K,\n\t\texpireMillisecond: number,\n\t\tobj: T[K],\n\t) => {\n\t\tclearExpiredItems();\n\t\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\t\tconst theObj = obj as any;\n\t\tif (!isHaveIndexedDb) {\n\t\t\treturn new Promise((res) => {\n\t\t\t\tlocalStorage.setItem(\n\t\t\t\t\t`[${dbName}] ${key as string}`,\n\t\t\t\t\tJSON.stringify({\n\t\t\t\t\t\tvalue: theObj,\n\t\t\t\t\t\texpire: expireMillisecond ? Date.now() + expireMillisecond : 0,\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t\tres(obj);\n\t\t\t});\n\t\t}\n\t\tif (!db) {\n\t\t\tawait initDb();\n\t\t}\n\t\treturn new Promise((res) => {\n\t\t\tif (db.objectStoreNames.contains(dbName)) {\n\t\t\t\tconst transaction = db.transaction([dbName], \"readwrite\");\n\t\t\t\tconst objectStore = transaction.objectStore(dbName);\n\t\t\t\tconst data = {\n\t\t\t\t\t[key]: key,\n\t\t\t\t\tvalue: theObj,\n\t\t\t\t\texpire: expireMillisecond ? Date.now() + expireMillisecond : 0,\n\t\t\t\t};\n\t\t\t\tconst request = objectStore.put(data, key as \"string\");\n\t\t\t\trequest.onerror = (err) => {\n\t\t\t\t\tconsole.error(err);\n\t\t\t\t\tres(obj);\n\t\t\t\t};\n\t\t\t\trequest.onsuccess = () => {\n\t\t\t\t\tres(obj);\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tres(obj);\n\t\t\t}\n\t\t});\n\t};\n\n\tconst assignEx = async <K extends keyof T>(\n\t\tkey: K,\n\t\texpireMillisecond: number,\n\t\tobj: T[K],\n\t): Promise<T[typeof key]> => {\n\t\tif (typeof obj !== \"object\") {\n\t\t\tthrow new Error(\"[NanoIndexed.assign] assign need is object\");\n\t\t}\n\t\tconst old = await out.get(key);\n\t\tif (!old) {\n\t\t\tout.setEx(key, expireMillisecond, obj);\n\t\t\treturn obj;\n\t\t}\n\t\tif (typeof old !== \"object\") {\n\t\t\treturn old;\n\t\t}\n\t\tconst next = Object.assign(old, obj);\n\t\tout.setEx(key, expireMillisecond, next);\n\t\treturn next;\n\t};\n\n\tconst del = async <K extends keyof T>(key: K): Promise<T[K] | undefined> => {\n\t\tdelete valueCache[key as string];\n\t\tif (!isHaveIndexedDb) {\n\t\t\treturn new Promise((res) => {\n\t\t\t\tlocalStorage.removeItem(`[${dbName}] ${key as string}`);\n\t\t\t\tres(void 0);\n\t\t\t});\n\t\t}\n\t\tif (!db) {\n\t\t\tawait initDb();\n\t\t}\n\n\t\treturn new Promise((res) => {\n\t\t\tif (db.objectStoreNames.contains(dbName)) {\n\t\t\t\tconst transaction = db.transaction([dbName], \"readwrite\");\n\t\t\t\tconst objectStore = transaction.objectStore(dbName);\n\t\t\t\tconst request = objectStore.delete(key as \"string\");\n\t\t\t\trequest.onerror = (err) => {\n\t\t\t\t\tconsole.error(err);\n\t\t\t\t\tres(void 0);\n\t\t\t\t};\n\t\t\t\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\t\t\t\trequest.onsuccess = res as any;\n\t\t\t} else {\n\t\t\t\tres(void 0);\n\t\t\t}\n\t\t});\n\t};\n\n\tconst clearExpiredItems = async (force = false) => {\n\t\tconst now = Date.now();\n\t\tif (!force && lastClearTime && now - lastClearTime < 60 * 1000 * 5) {\n\t\t\t// Less than 5 minutes has passed since the last clear, so we do nothing\n\t\t\treturn;\n\t\t}\n\t\tlastClearTime = now;\n\n\t\treturn getAll();\n\t};\n\n\tclearExpiredItems();\n\n\tconst flushDb = async () => {\n\t\tconst all = await getAll();\n\t\tawait Promise.all(\n\t\t\tObject.keys(all).map((key) => {\n\t\t\t\treturn del(key as keyof T);\n\t\t\t}),\n\t\t);\n\t};\n\n\tlet reduceValueCache = 0;\n\n\tconst runSetExJobs = debounce(500, () => {\n\t\treduceValueCache++;\n\t\tif (reduceValueCache > 200) {\n\t\t\treduceValueCache = 0;\n\t\t\tObject.keys(valueCache).forEach((k) => {\n\t\t\t\tconst v = valueCache[k];\n\t\t\t\tif (v.expire && v.expire < Date.now()) {\n\t\t\t\t\tdelete valueCache[k];\n\t\t\t\t}\n\t\t\t});\n\t\t\tconst keys = Object.keys(valueCache);\n\t\t\tif (keys.length > 500) {\n\t\t\t\tvalueCache = {};\n\t\t\t}\n\t\t}\n\n\t\tconst keys = Object.keys(setExJobs);\n\t\tif (keys.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tkeys.forEach((key) => {\n\t\t\t// biome-ignore lint/suspicious/noExplicitAny: <explanation>\n\t\t\tconst job = setExJobs[key] as any;\n\t\t\tif (job) {\n\t\t\t\tsetEx(key as keyof T, job.expire, job.value);\n\t\t\t}\n\t\t});\n\t\tsetExJobs = {};\n\t});\n\n\tconst out = {\n\t\tset: async <K extends keyof T>(key: K, value: T[K]) => {\n\t\t\tout.setEx(key, 0, value);\n\t\t},\n\t\tsetEx: async (\n\t\t\tkey: keyof T,\n\t\t\texpireMillisecond: number,\n\t\t\tvalue: T[typeof key],\n\t\t) => {\n\t\t\tconst now = Date.now();\n\t\t\tsetExJobs[key as string] = {\n\t\t\t\texpire: expireMillisecond ? now + expireMillisecond : 0,\n\t\t\t\tvalue,\n\t\t\t};\n\t\t\tvalueCache[key as string] = {\n\t\t\t\texpire: expireMillisecond ? now + expireMillisecond : 0,\n\t\t\t\tvalue,\n\t\t\t};\n\t\t\trunSetExJobs();\n\t\t},\n\t\tget: async <K extends keyof T>(key: K): Promise<T[K] | undefined> => {\n\t\t\tconst old = getCacheValue(key as string);\n\t\t\tif (old !== void 0) {\n\t\t\t\treturn old;\n\t\t\t}\n\t\t\treturn get(key);\n\t\t},\n\t\tgetAll,\n\t\tassignEx,\n\t\tdel,\n\t\tflushDb,\n\t\tclearExpiredItems,\n\t};\n\treturn out;\n};\n"
  ],
  "mappings": "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",
  "debugId": "17E5C0980F6A924564756e2164756e21",
  "names": []
}